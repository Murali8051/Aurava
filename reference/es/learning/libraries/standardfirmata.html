<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
	<head>
		<title>StandardFirmata \ Learning \ Wiring</title>
		
		<link rel="icon" href="img/wiring-1.ico" type="image/x-icon" />
		<link rel="shortcut icon" href="img/wiring-1.ico" type="image/x-icon" />
		
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="Author" content="Hernando Barragán" />
		<meta name="Publisher" content="Wiring" />
		<meta name="Keywords" content="Wiring, Processing, Interactive Media, Electronic Arts, Programming, C, C++, Hernando Barragán" />
		<meta name="Description" content="Wiring is an electronic sketchbook and hardware electronics for developing 
				ideas. It is a context for learning fundamentals of computer programming and prototyping with electronics
				within the context of the electronic arts." />
		<meta name="Copyright" content="All contents copyright Hernando Barragán" />
		
		<script src="../../javascript/MM_functions.js" type="text/javascript"></script>
	
		<link href="../../css/style.css" rel="stylesheet" type="text/css" />
	</head>
	<body id="Library" onload="" >
		
		<!-- ==================================== PAGE ============================ --> 
		<div id="container">
	
			<!-- ==================================== HEADER ============================ --> 
			<div id="header">
				<a href="../../index.html"><img src="../../img/wiring_cover.gif" alt="Wiring cover" title="Back to the reference index." /></a>
				<form name="search" method="get" action="http://www.google.com/search">
				<label>Search wiring.org.co:</label> 
				       <p><input type="hidden" name="as_sitesearch" value="wiring.org.co" />
				       <input type="text" name="as_q" value="" size="20" class="text" /> 
						<input type="image" src="../../img/search_button.gif" value="Submit" alt="Submit" /></p>
				</form>
			</div> 
						<div id="navigation">
				<div class="navBar" id="mainnav">
					<a href="../../index.html">Framework</a> (<a href="../../alpha.html">A-Z</a>) \ 
					<a href="../../libraries/index.html">Librer&iacute;as</a> \ 
					<a href="../../environment/index.html">Entorno</a> \ 
					<a href="../../learning/index.html" class="active">Aprendiendo</a> \
					<a href="../../hardware/index.html">Hardware</a> 
				</div>
				<div class="navBar learning_local" id="subNav">
					 
 Ejemplos: 					<a href="../../learning/basics/index.html">B&aacute;sicos</a>, 
					<a href="../../learning/libraries/index.html" class="active">Librer&iacute;a</a>, 
					<a href="../../learning/topics/index.html">T&oacute;picos</a> 
				</div>
			</div>

		
			<a id="TOP" name="TOP"></a>
			
			<!-- ==================================== CONTENT - Headers ============================ -->
			<div class="content">
			 
			 
<div class="examples-nav-div">
<table width="480" border="0"><tr><td align="left"><table>
<tr><td><a href="simpledigitalfirmata.html">
				<img src="../../img/back_off.gif" alt="Digital input/output pins" /></a></td><td>
<select name="nav" size="1" class="inputnav" onChange="javascript:gogo(this)">
	<optgroup label="Wire">
		<option value="digitalpotentiometer.html">Digital potentiometer: AD5171</option>
		<option value="masterreader.html">Master reader</option>
		<option value="masterwriter.html">Master writer</option>
		<option value="slavereceiver.html">Slave receiver</option>
		<option value="slavesender.html">Slave sender</option>
		<option value="ultrasonicsfr.html">Ultrasonic ranger: SFR08/SFR10</option>
		<option value="hmc6352sparkfun.html">Compass heading: HMC6352 sparkfun</option>
		<option value="hmc6343sparkfun.html">Compass heading with tilt compensation: HMC6352 sparkfun</option>
		<option value="realtimeclock.html">Real time clock: DS1307 sparkfun</option>
		<option value="bmp085.html">Temperature and barometric pressure: Sparkfun BOSCH BMP085</option>
		<option value="tmp102sparkfun.html">Temperature: Sparkfun tmp102</option>
	</optgroup>
	<optgroup label="SPI">
		<option value="barometricpressuresensor.html">Barometric pressure: SCP1000</option>
		<option value="gyromlx90609.html">MLX90609 Gyroscope: Sparkfun</option>
	</optgroup>
	<optgroup label="Servo">
		<option value="servomotor.html">Servo moving</option>
		<option value="servomultiple.html">Multiple servos</option>
		<option value="servoanaloginput.html">Servo & potentiometer</option>
	</optgroup>
	<optgroup label="Matrix">
		<option value="hellomatrix.html">Hello Matrix</option>
		<option value="spriteanimation.html">Sprite animation</option>
	</optgroup>
	<optgroup label="LiquidCrystal">
		<option value="printdata.html">Printing data to parallel LCD display</option>
	</optgroup>
	<optgroup label="Encoder">
		<option value="encoderread.html">Encoder read</option>
	</optgroup>
	<optgroup label="EEPROM">
		<option value="storedata.html">Storing data</option>
	</optgroup>
	<optgroup label="EEPROMVar">
		<option value="helloeepromvar.html">EEPROM data variables</option>
	</optgroup>
	<optgroup label="Firmata">
		<option value="allinputsfirmata.html">All inputs</option>
		<option value="analogfirmata.html">Analog inputs</option>
		<option value="echostring.html">Strings accept and echoing</option>
		<option value="i2cfirmata.html">Wire & Firmata</option>
		<option value="oldstandardfirmata.html">Old Standard protocol</option>
		<option value="servofirmata.html">Servo & Firmata</option>
		<option value="simpleanalogfirmata.html">Analog input/output pins</option>
		<option value="simpledigitalfirmata.html">Digital input/output pins</option>
		<option value="standardfirmata.html" selected="selected">Standard protocol</option>
	</optgroup>
	<optgroup label="NewSoftSerial">
		<option value="newsoftserialtest.html">Software serial port test</option>
		<option value="twonsstest.html">Two ports</option>
	</optgroup>
	<optgroup label="Stepper">
		<option value="steppermove.html">Stepper move</option>
	</optgroup>
	<optgroup label="NMEA">
		<option value="basicpositioning.html">Basic positioning</option>
		<option value="coursetodestination.html">Course to destination</option>
		<option value="determiningspeed.html">Determining speed</option>
		<option value="distancetodestination.html">Distance to destination</option>
		<option value="nmeasentence.html">NMEA Sentence</option>
	</optgroup>
	<optgroup label="Button">
		<option value="button.html">Button object</option>
		<option value="eventbutton.html">Event API for buttons</option>
		<option value="pollingcomplexbutton.html">Button polling technique</option>
	</optgroup>
	<optgroup label="Constrain">
		<option value="simpleconstrain.html">Constrained variables</option>
	</optgroup>
	<optgroup label="FluentPrint">
		<option value="hellofluentprint.html">Hello fluent print</option>
	</optgroup>
	<optgroup label="FSM">
		<option value="ledstatemachine.html">LED state machine</option>
	</optgroup>
	<optgroup label="HashMap">
		<option value="hellohashmap.html">Hello Hashmap</option>
	</optgroup>
	<optgroup label="Keypad">
		<option value="customkeypad.html">Custom Keypad</option>
		<option value="dynamickeypad.html">Dynamic Keypad</option>
		<option value="eventkeypad.html">Event Keypad</option>
		<option value="hellokeypad.html">Hello Keypad</option>
	</optgroup>
	<optgroup label="LED">
		<option value="blink.html">Blink</option>
		<option value="loop.html">Loop</option>
	</optgroup>
	<optgroup label="MenuBackend">
		<option value="hellomenu.html">Hello Menu</option>
	</optgroup>
	<optgroup label="OSC">
		<option value="helloosc.html">Hello OSC (Open Sound Control)</option>
	</optgroup>
	<optgroup label="Messenger">
		<option value="basic_communication.html">Basic communication</option>
		<option value="checkstring.html">Check string</option>
		<option value="copystring.html">Copy string</option>
	</optgroup>
	<optgroup label="Password">
		<option value="hellopassword.html">Hello Password</option>
		<option value="passwordkeypad.html">Password Keypad</option>
		<option value="serialmonitor.html">Serial Monitor</option>
	</optgroup>
	<optgroup label="Potentiometer">
		<option value="potcontrol_led.html">PotControl LED</option>
		<option value="potdemo.html">Pot Demo</option>
	</optgroup>
	<optgroup label="Scheduler">
		<option value="delayedsignal.html">Delayed Signal</option>
	</optgroup>
	<optgroup label="Supervisor">
		<option value="hellosupervisor.html">Hello Supervisor</option>
	</optgroup>
	<optgroup label="TimedAction">
		<option value="hellotimedaction.html">Hello Timed Action</option>
		<option value="threeexamplesatonce.html">Three Examples At Once</option>
	</optgroup>
</select>

</td><td><a class="next" href="newsoftserialtest.html">
				<img src="../../img/next_off.gif" alt="Software serial port test" /></a></td></tr></table></td></tr></table></div>

<p class="ref-notice">This example is for Wiring version 1.0 build 0100+. If you have a previous version, use the examples included with your software. <em>If you see any errors or have comments, please <a href="http://forum.wiring.co/index.php/board,13.0.html">let us know</a>.</em></p>


<div class="example">Copyright (C) 2006-2008 Hans-Christoph Steiner.  All rights reserved. <br />
<br />
 This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. See file LICENSE.txt for further informations on licensing terms. formatted using the GNU C formatting and indenting</p>
<p></p>

<p class="doc">
<pre class="code">
<span class='comment'>/* 
 * TODO: use Program Control to load stored profiles from EEPROM
 */</span>

#<span class='keyword1'>include</span> &lt;Servo.h&gt;
#<span class='keyword1'>include</span> &lt;Firmata.h&gt;

<span class='comment'>/*==============================================================================
 * GLOBAL VARIABLES
 *============================================================================*/</span>

<span class='comment'>/* analog inputs */</span>
<span class='keyword1'>int</span> analogInputsToReport = 0; <span class='comment'>// bitwise array to store pin reporting</span>

<span class='comment'>/* digital input ports */</span>
<span class='keyword1'>byte</span> reportPINs[TOTAL_PORTS];       <span class='comment'>// 1 = report <span class='literal2'><span class='keyword1'>this</span></span> port, 0 = silence</span>
<span class='keyword1'>byte</span> previousPINs[TOTAL_PORTS];     <span class='comment'>// previous 8 bits sent</span>

<span class='comment'>/* pins configuration */</span>
<span class='keyword1'>byte</span> pinConfig[<span class='literal2'>TOTAL_PINS</span>];         <span class='comment'>// configuration of every pin</span>
<span class='keyword1'>byte</span> portConfigInputs[TOTAL_PORTS]; <span class='comment'>// each <span class='keyword2'>bit</span>: 1 = pin in <span class='literal2'>INPUT</span>, 0 = anything <span class='keyword1'>else</span></span>
<span class='keyword1'>int</span> pinState[<span class='literal2'>TOTAL_PINS</span>];           <span class='comment'>// any value that has been written</span>

<span class='comment'>/* timer variables */</span>
<span class='keyword1'>unsigned</span> <span class='keyword1'>long</span> currentMillis;        <span class='comment'>// store the current value from <span class='keyword2'>millis</span>()</span>
<span class='keyword1'>unsigned</span> <span class='keyword1'>long</span> previousMillis;       <span class='comment'>// <span class='keyword1'>for</span> comparison with currentMillis</span>
<span class='keyword1'>int</span> samplingInterval = 19;          <span class='comment'>// how often to run the main <span class='keyword2'>loop</span> (in ms)</span>

Servo servos[MAX_SERVOS];

<span class='comment'>/*==============================================================================
 * FUNCTIONS
 *============================================================================*/</span>

<span class='keyword1'>void</span> outputPort(<span class='keyword1'>byte</span> portNumber, <span class='keyword1'>byte</span> portValue, <span class='keyword1'>byte</span> forceSend)
{
  <span class='comment'>// pins not configured as <span class='literal2'>INPUT</span> are cleared to zeros</span>
  portValue = portValue &amp; portConfigInputs[portNumber];
  <span class='comment'>// only send <span class='keyword1'>if</span> the value is different than previously sent</span>
  <span class='keyword1'>if</span> (forceSend || previousPINs[portNumber] != portValue) {
    Firmata.sendDigitalPort(portNumber, portValue);
    previousPINs[portNumber] = portValue;
  }
}

<span class='comment'>/* -----------------------------------------------------------------------------
 * check all the active digital inputs <span class='keyword1'>for</span> change of state, then <span class='keyword2'>add</span> any events
 * to the <span class='keyword1'>Serial</span> output queue <span class='keyword2'>using</span> <span class='keyword1'>Serial</span>.<span class='keyword2'>print</span>() */</span>
<span class='keyword1'>void</span> checkDigitalInputs(<span class='keyword1'>void</span>)
{
  <span class='comment'>/* Using non-looping code allows constants to be given to readPort().
   * The compiler will apply substantial optimizations <span class='keyword1'>if</span> the inputs
   * to readPort() are compile-time constants. */</span>
  <span class='keyword1'>if</span> (TOTAL_PORTS &gt; 0 &amp;&amp; reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), <span class='keyword1'>false</span>);
  <span class='keyword1'>if</span> (TOTAL_PORTS &gt; 1 &amp;&amp; reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), <span class='keyword1'>false</span>);
  <span class='keyword1'>if</span> (TOTAL_PORTS &gt; 2 &amp;&amp; reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), <span class='keyword1'>false</span>);
  <span class='keyword1'>if</span> (TOTAL_PORTS &gt; 3 &amp;&amp; reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), <span class='keyword1'>false</span>);
  <span class='keyword1'>if</span> (TOTAL_PORTS &gt; 4 &amp;&amp; reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), <span class='keyword1'>false</span>);
  <span class='keyword1'>if</span> (TOTAL_PORTS &gt; 5 &amp;&amp; reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), <span class='keyword1'>false</span>);
  <span class='keyword1'>if</span> (TOTAL_PORTS &gt; 6 &amp;&amp; reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), <span class='keyword1'>false</span>);
  <span class='keyword1'>if</span> (TOTAL_PORTS &gt; 7 &amp;&amp; reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), <span class='keyword1'>false</span>);
  <span class='keyword1'>if</span> (TOTAL_PORTS &gt; 8 &amp;&amp; reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), <span class='keyword1'>false</span>);
  <span class='keyword1'>if</span> (TOTAL_PORTS &gt; 9 &amp;&amp; reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), <span class='keyword1'>false</span>);
  <span class='keyword1'>if</span> (TOTAL_PORTS &gt; 10 &amp;&amp; reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), <span class='keyword1'>false</span>);
  <span class='keyword1'>if</span> (TOTAL_PORTS &gt; 11 &amp;&amp; reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), <span class='keyword1'>false</span>);
  <span class='keyword1'>if</span> (TOTAL_PORTS &gt; 12 &amp;&amp; reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), <span class='keyword1'>false</span>);
  <span class='keyword1'>if</span> (TOTAL_PORTS &gt; 13 &amp;&amp; reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), <span class='keyword1'>false</span>);
  <span class='keyword1'>if</span> (TOTAL_PORTS &gt; 14 &amp;&amp; reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), <span class='keyword1'>false</span>);
  <span class='keyword1'>if</span> (TOTAL_PORTS &gt; 15 &amp;&amp; reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), <span class='keyword1'>false</span>);
}

<span class='comment'>// -----------------------------------------------------------------------------</span>
<span class='comment'>/* sets the pin mode to the correct state and sets the relevant bits in the
 * two <span class='keyword2'>bit</span>-arrays that track Digital I/O and PWM status
 */</span>
<span class='keyword1'>void</span> setPinModeCallback(<span class='keyword1'>byte</span> pin, <span class='keyword1'>int</span> mode)
{
  <span class='keyword1'>if</span> (IS_PIN_SERVO(pin) &amp;&amp; mode != SERVO &amp;&amp; servos[PIN_TO_SERVO(pin)].attached()) {
    servos[PIN_TO_SERVO(pin)].detach();
  }
  <span class='keyword1'>if</span> (IS_PIN_ANALOG(pin)) {
    reportAnalogCallback(PIN_TO_ANALOG(pin), mode == ANALOG ? 1 : 0); <span class='comment'>// turn on/off reporting</span>
  }
  <span class='keyword1'>if</span> (IS_PIN_DIGITAL(pin)) {
    <span class='keyword1'>if</span> (mode == <span class='literal2'>INPUT</span>) {
      portConfigInputs[pin/8] |= (1 &lt;&lt; (pin &amp; 7));
    } <span class='keyword1'>else</span> {
      portConfigInputs[pin/8] &amp;= ~(1 &lt;&lt; (pin &amp; 7));
    }
  }
  pinState[pin] = 0;
  <span class='keyword1'>switch</span> (mode) {
  <span class='keyword1'>case</span> ANALOG:
    <span class='keyword1'>if</span> (IS_PIN_ANALOG(pin)) {
      <span class='keyword1'>if</span> (IS_PIN_DIGITAL(pin)) {
        <span class='keyword2'>pinMode</span>(PIN_TO_DIGITAL(pin), <span class='literal2'>INPUT</span>); <span class='comment'>// disable output driver</span>
        <span class='keyword2'>digitalWrite</span>(PIN_TO_DIGITAL(pin), <span class='literal2'>LOW</span>); <span class='comment'>// disable internal pull-ups</span>
      }
      pinConfig[pin] = ANALOG;
    }
    <span class='keyword1'>break</span>;
  <span class='keyword1'>case</span> <span class='literal2'>INPUT</span>:
    <span class='keyword1'>if</span> (IS_PIN_DIGITAL(pin)) {
      <span class='keyword2'>pinMode</span>(PIN_TO_DIGITAL(pin), <span class='literal2'>INPUT</span>); <span class='comment'>// disable output driver</span>
      <span class='keyword2'>digitalWrite</span>(PIN_TO_DIGITAL(pin), <span class='literal2'>LOW</span>); <span class='comment'>// disable internal pull-ups</span>
      pinConfig[pin] = <span class='literal2'>INPUT</span>;
    }
    <span class='keyword1'>break</span>;
  <span class='keyword1'>case</span> <span class='literal2'>OUTPUT</span>:
    <span class='keyword1'>if</span> (IS_PIN_DIGITAL(pin)) {
      <span class='keyword2'>digitalWrite</span>(PIN_TO_DIGITAL(pin), <span class='literal2'>LOW</span>); <span class='comment'>// disable PWM</span>
      <span class='keyword2'>pinMode</span>(PIN_TO_DIGITAL(pin), <span class='literal2'>OUTPUT</span>);
      pinConfig[pin] = <span class='literal2'>OUTPUT</span>;
    }
    <span class='keyword1'>break</span>;
  <span class='keyword1'>case</span> PWM:
    <span class='keyword1'>if</span> (IS_PIN_PWM(pin)) {
      <span class='keyword2'>pinMode</span>(PIN_TO_PWM(pin), <span class='literal2'>OUTPUT</span>);
      <span class='keyword2'>analogWrite</span>(PIN_TO_PWM(pin), 0);
      pinConfig[pin] = PWM;
    }
    <span class='keyword1'>break</span>;
  <span class='keyword1'>case</span> SERVO:
    <span class='keyword1'>if</span> (IS_PIN_SERVO(pin)) {
      pinConfig[pin] = SERVO;
      <span class='keyword1'>if</span> (!servos[PIN_TO_SERVO(pin)].attached()) {
          servos[PIN_TO_SERVO(pin)].attach(PIN_TO_DIGITAL(pin));
      } <span class='keyword1'>else</span> {
        Firmata.sendString(<span class='literal'>"Servo only on digital pins"</span>);
      }
    }
    <span class='keyword1'>break</span>;
  <span class='keyword1'>case</span> I2C:
    pinConfig[pin] = mode;
    Firmata.sendString(<span class='literal'>"I2C mode not yet supported"</span>);
    <span class='keyword1'>break</span>;
  <span class='keyword1'>default</span>:
    Firmata.sendString(<span class='literal'>"Unknown pin mode"</span>); <span class='comment'>// TODO: put error msgs in EEPROM</span>
  }
  <span class='comment'>// TODO: save status to EEPROM here, <span class='keyword1'>if</span> changed</span>
}

<span class='keyword1'>void</span> analogWriteCallback(<span class='keyword1'>byte</span> pin, <span class='keyword1'>int</span> value)
{
  <span class='keyword1'>if</span> (pin &lt; <span class='literal2'>TOTAL_PINS</span>) {
    <span class='keyword1'>switch</span> (pinConfig[pin]) {
    <span class='keyword1'>case</span> SERVO:
      <span class='keyword1'>if</span> (IS_PIN_SERVO(pin))
        servos[PIN_TO_SERVO(pin)].<span class='keyword2'>write</span>(value);
        pinState[pin] = value;
      <span class='keyword1'>break</span>;
    <span class='keyword1'>case</span> PWM:
      <span class='keyword1'>if</span> (IS_PIN_PWM(pin))
        <span class='keyword2'>analogWrite</span>(PIN_TO_PWM(pin), value);
        pinState[pin] = value;
      <span class='keyword1'>break</span>;
    }
  }
}

<span class='keyword1'>void</span> digitalWriteCallback(<span class='keyword1'>byte</span> port, <span class='keyword1'>int</span> value)
{
  <span class='keyword1'>byte</span> pin, lastPin, mask=1, pinWriteMask=0;

  <span class='keyword1'>if</span> (port &lt; TOTAL_PORTS) {
    <span class='comment'>// create a mask of the pins on <span class='literal2'><span class='keyword1'>this</span></span> port that are writable.</span>
    lastPin = port*8+8;
    <span class='keyword1'>if</span> (lastPin &gt; <span class='literal2'>TOTAL_PINS</span>) lastPin = <span class='literal2'>TOTAL_PINS</span>;
    <span class='keyword1'>for</span> (pin=port*8; pin &lt; lastPin; pin++) {
      <span class='comment'>// <span class='keyword1'>do</span> not disturb non-digital pins (eg, Rx &amp; Tx)</span>
      <span class='keyword1'>if</span> (IS_PIN_DIGITAL(pin)) {
        <span class='comment'>// only <span class='keyword2'>write</span> to <span class='literal2'>OUTPUT</span> and <span class='literal2'>INPUT</span> (enables <span class='keyword2'>pullup</span>)</span>
        <span class='comment'>// <span class='keyword1'>do</span> not touch pins in PWM, ANALOG, SERVO or other modes</span>
        <span class='keyword1'>if</span> (pinConfig[pin] == <span class='literal2'>OUTPUT</span> || pinConfig[pin] == <span class='literal2'>INPUT</span>) {
          pinWriteMask |= mask;
          pinState[pin] = ((<span class='keyword1'>byte</span>)value &amp; mask) ? 1 : 0;
        }
      }
      mask = mask &lt;&lt; 1;
    }
    writePort(port, (<span class='keyword1'>byte</span>)value, pinWriteMask);
  }
}


<span class='comment'>// -----------------------------------------------------------------------------</span>
<span class='comment'>/* sets bits in a <span class='keyword2'>bit</span> array (<span class='keyword1'>int</span>) to toggle the reporting of the analogIns
 */</span>
<span class='comment'>//<span class='keyword1'>void</span> FirmataClass::setAnalogPinReporting(<span class='keyword1'>byte</span> pin, <span class='keyword1'>byte</span> state) {</span>
<span class='comment'>//}</span>
<span class='keyword1'>void</span> reportAnalogCallback(<span class='keyword1'>byte</span> analogPin, <span class='keyword1'>int</span> value)
{
  <span class='keyword1'>if</span> (analogPin &lt; <span class='literal2'>TOTAL_ANALOG_PINS</span>) {
    <span class='keyword1'>if</span> (value == 0) {
      analogInputsToReport = analogInputsToReport &amp;~ (1 &lt;&lt; analogPin);
    } <span class='keyword1'>else</span> {
      analogInputsToReport = analogInputsToReport | (1 &lt;&lt; analogPin);
    }
  }
  <span class='comment'>// TODO: save status to EEPROM here, <span class='keyword1'>if</span> changed</span>
}

<span class='keyword1'>void</span> reportDigitalCallback(<span class='keyword1'>byte</span> port, <span class='keyword1'>int</span> value)
{
  <span class='keyword1'>if</span> (port &lt; TOTAL_PORTS) {
    reportPINs[port] = (<span class='keyword1'>byte</span>)value;
  }
  <span class='comment'>// <span class='keyword1'>do</span> not disable analog reporting on these 8 pins, to allow some</span>
  <span class='comment'>// pins used <span class='keyword1'>for</span> digital, others analog.  Instead, allow both types</span>
  <span class='comment'>// of reporting to be enabled, but check <span class='keyword1'>if</span> the pin is configured</span>
  <span class='comment'>// as analog when sampling the analog inputs.  Likewise, <span class='keyword1'>while</span></span>
  <span class='comment'>// scanning digital pins, portConfigInputs will mask off values from any</span>
  <span class='comment'>// pins configured as analog</span>
}

<span class='comment'>/*==============================================================================
 * SYSEX-BASED commands
 *============================================================================*/</span>

<span class='keyword1'>void</span> sysexCallback(<span class='keyword1'>byte</span> command, <span class='keyword1'>byte</span> argc, <span class='keyword1'>byte</span> *argv)
{
  <span class='keyword1'>switch</span> (command) {
  <span class='keyword1'>case</span> SERVO_CONFIG:
    <span class='keyword1'>if</span> (argc &gt; 4) {
      <span class='comment'>// these vars are here <span class='keyword1'>for</span> clarity, they'll optimized away by the compiler</span>
      <span class='keyword1'>byte</span> pin = argv[0];
      <span class='keyword1'>int</span> minPulse = argv[1] + (argv[2] &lt;&lt; 7);
      <span class='keyword1'>int</span> maxPulse = argv[3] + (argv[4] &lt;&lt; 7);

      <span class='keyword1'>if</span> (IS_PIN_SERVO(pin)) {
        <span class='comment'>// servos are pins from 2 to 13, so offset <span class='keyword1'>for</span> array</span>
        <span class='keyword1'>if</span> (servos[PIN_TO_SERVO(pin)].attached())
          servos[PIN_TO_SERVO(pin)].detach();
        servos[PIN_TO_SERVO(pin)].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse);
        setPinModeCallback(pin, SERVO);
      }
    }
    <span class='keyword1'>break</span>;
  <span class='keyword1'>case</span> SAMPLING_INTERVAL:
    <span class='keyword1'>if</span> (argc &gt; 1)
      samplingInterval = argv[0] + (argv[1] &lt;&lt; 7);
    <span class='keyword1'>else</span>
      Firmata.sendString(<span class='literal'>"Not enough data"</span>);
    <span class='keyword1'>break</span>;
  <span class='keyword1'>case</span> EXTENDED_ANALOG:
    <span class='keyword1'>if</span> (argc &gt; 1) {
      <span class='keyword1'>int</span> val = argv[1];
      <span class='keyword1'>if</span> (argc &gt; 2) val |= (argv[2] &lt;&lt; 7);
      <span class='keyword1'>if</span> (argc &gt; 3) val |= (argv[3] &lt;&lt; 14);
      analogWriteCallback(argv[0], val);
    }
    <span class='keyword1'>break</span>;
  <span class='keyword1'>case</span> CAPABILITY_QUERY:
    <span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>(START_SYSEX);
    <span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>(CAPABILITY_RESPONSE);
    <span class='keyword1'>for</span> (<span class='keyword1'>byte</span> pin=0; pin &lt; <span class='literal2'>TOTAL_PINS</span>; pin++) {
      <span class='keyword1'>if</span> (IS_PIN_DIGITAL(pin)) {
        <span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>((<span class='keyword1'>byte</span>)<span class='literal2'>INPUT</span>);
        <span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>(1);
        <span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>((<span class='keyword1'>byte</span>)<span class='literal2'>OUTPUT</span>);
        <span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>(1);
      }
      <span class='keyword1'>if</span> (IS_PIN_ANALOG(pin)) {
        <span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>(ANALOG);
        <span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>(10);
      }
      <span class='keyword1'>if</span> (IS_PIN_PWM(pin)) {
        <span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>(PWM);
        <span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>(8);
      }
      <span class='keyword1'>if</span> (IS_PIN_SERVO(pin)) {
        <span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>(SERVO);
        <span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>(14);
      }
      <span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>(127);
    }
    <span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>(END_SYSEX);
    <span class='keyword1'>break</span>;
  <span class='keyword1'>case</span> PIN_STATE_QUERY:
    <span class='keyword1'>if</span> (argc &gt; 0) {
      <span class='keyword1'>byte</span> pin=argv[0];
      <span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>(START_SYSEX);
      <span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>(PIN_STATE_RESPONSE);
      <span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>(pin);
      <span class='keyword1'>if</span> (pin &lt; <span class='literal2'>TOTAL_PINS</span>) {
        <span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>((<span class='keyword1'>byte</span>)pinConfig[pin]);
	<span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>((<span class='keyword1'>byte</span>)pinState[pin] &amp; 0x7F);
	<span class='keyword1'>if</span> (pinState[pin] &amp; 0xFF80) <span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>((<span class='keyword1'>byte</span>)(pinState[pin] &gt;&gt; 7) &amp; 0x7F);
	<span class='keyword1'>if</span> (pinState[pin] &amp; 0xC000) <span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>((<span class='keyword1'>byte</span>)(pinState[pin] &gt;&gt; 14) &amp; 0x7F);
      }
      <span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>(END_SYSEX);
    }
    <span class='keyword1'>break</span>;
  <span class='keyword1'>case</span> ANALOG_MAPPING_QUERY:
    <span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>(START_SYSEX);
    <span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>(ANALOG_MAPPING_RESPONSE);
    <span class='keyword1'>for</span> (<span class='keyword1'>byte</span> pin=0; pin &lt; <span class='literal2'>TOTAL_PINS</span>; pin++) {
      <span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127);
    }
    <span class='keyword1'>Serial</span>.<span class='keyword2'>write</span>(END_SYSEX);
    <span class='keyword1'>break</span>;
  }
}


<span class='comment'>/*==============================================================================
 * SETUP()
 *============================================================================*/</span>
<span class='keyword1'>void</span> <span class='keyword2'>setup</span>() 
{
  <span class='keyword1'>byte</span> i;

  Firmata.setFirmwareVersion(2, 2);

  Firmata.attach(ANALOG_MESSAGE, analogWriteCallback);
  Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback);
  Firmata.attach(REPORT_ANALOG, reportAnalogCallback);
  Firmata.attach(REPORT_DIGITAL, reportDigitalCallback);
  Firmata.attach(SET_PIN_MODE, setPinModeCallback);
  Firmata.attach(START_SYSEX, sysexCallback);

  <span class='comment'>// TODO: load state from EEPROM here</span>

  <span class='comment'>/* these are initialized to zero by the compiler startup code
  <span class='keyword1'>for</span> (i=0; i &lt; TOTAL_PORTS; i++) {
    reportPINs[i] = <span class='keyword1'>false</span>;
    portConfigInputs[i] = 0;
    previousPINs[i] = 0;
  }
  */</span>
  <span class='keyword1'>for</span> (i=0; i &lt; <span class='literal2'>TOTAL_PINS</span>; i++) {
    <span class='keyword1'>if</span> (IS_PIN_ANALOG(i)) {
      <span class='comment'>// turns off <span class='keyword2'>pullup</span>, configures everything</span>
      setPinModeCallback(i, ANALOG);
    } <span class='keyword1'>else</span> {
      <span class='comment'>// sets the output to 0, configures portConfigInputs</span>
      setPinModeCallback(i, <span class='literal2'>OUTPUT</span>);
    }
  }
  <span class='comment'>// by defult, <span class='keyword1'>do</span> not report any analog inputs</span>
  analogInputsToReport = 0;

  Firmata.<span class='keyword2'>begin</span>(57600);

  <span class='comment'>/* send digital inputs to set the initial state on the host computer,
   * since once in the <span class='keyword2'>loop</span>(), <span class='literal2'><span class='keyword1'>this</span></span> firmware will only send on change */</span>
  <span class='keyword1'>for</span> (i=0; i &lt; TOTAL_PORTS; i++) {
    outputPort(i, readPort(i, portConfigInputs[i]), <span class='keyword1'>true</span>);
  }
}

<span class='comment'>/*==============================================================================
 * LOOP()
 *============================================================================*/</span>
<span class='keyword1'>void</span> <span class='keyword2'>loop</span>() 
{
  <span class='keyword1'>byte</span> pin, analogPin;

  <span class='comment'>/* DIGITALREAD - as fast as possible, check <span class='keyword1'>for</span> changes and output them to the
   * FTDI buffer <span class='keyword2'>using</span> <span class='keyword1'>Serial</span>.<span class='keyword2'>print</span>()  */</span>
  checkDigitalInputs();  

  <span class='comment'>/* SERIALREAD - processing incoming messagse as soon as possible, <span class='keyword1'>while</span> still
   * checking digital inputs.  */</span>
  <span class='keyword1'>while</span>(Firmata.<span class='keyword2'>available</span>())
    Firmata.processInput();

  <span class='comment'>/* SEND FTDI WRITE BUFFER - make sure that the FTDI buffer doesn't go over
   * 60 bytes. use a timer to sending an event character every 4 ms to
   * trigger the buffer to dump. */</span>

  currentMillis = <span class='keyword2'>millis</span>();
  <span class='keyword1'>if</span> (currentMillis - previousMillis &gt; samplingInterval) {
    previousMillis += samplingInterval;
    <span class='comment'>/* ANALOGREAD - <span class='keyword1'>do</span> all analogReads() at the configured sampling interval */</span>
    <span class='keyword1'>for</span> (pin=0; pin&lt;<span class='literal2'>TOTAL_PINS</span>; pin++) {
      <span class='keyword1'>if</span> (IS_PIN_ANALOG(pin) &amp;&amp; pinConfig[pin] == ANALOG) {
        analogPin = PIN_TO_ANALOG(pin);
        <span class='keyword1'>if</span> (analogInputsToReport &amp; (1 &lt;&lt; analogPin)) {
          Firmata.sendAnalog(analogPin, <span class='keyword2'>analogRead</span>(analogPin));
        }
      }
    }
  }
}
</pre>


</div>


			
			</div>

			<!-- ==================================== FOOTER ============================ --> 
  			<div id="footer">
    			<div id="copyright">Wiring is an open project initiated by <a href="http://barraganstudio.com" target="_blank">Hernando Barrag&aacute;n</a>. It is developed by a <a href="http://wiring.org.co/about.html">small team of volunteers</a>.</div>  
		  <div id="colophon">

                    <a href="../../copyright.html">&copy; Info</a>, Processing <a href="http://processing.org/copyright.html">&copy; Info</a></div>
		  </div>
  			
		</div>
	</body>
</html>
